--# selene: allow(unused_variable)
---@diagnostic disable: unused-local

-- Read file {fname} and return a |List|, each line of the file
-- 		as an item.  Lines are broken at NL characters.  Macintosh
-- 		files separated with CR will result in a single long line
-- 		(unless a NL appears somewhere).
-- 		All NUL characters are replaced with a NL character.
-- 		When {binary} contains "b" binary mode is used:
-- 		- When the last line ends in a NL an extra empty list item is
-- 		  added.
-- 		- No CR characters are removed.
-- 		Otherwise:
-- 		- CR characters that appear before a NL are removed.
-- 		- Whether the last line ends in a NL or not does not matter.
-- 		- Any UTF-8 byte order mark is removed from the text.
-- 		When {max} is given this specifies the maximum number of lines
-- 		to be read.  Useful if you only want to check the first ten
-- 		lines of a file: >
-- 			:for line in readfile(fname, '', 10)
-- 			:  if line =~ 'Date' | echo line | endif
-- 			:endfor
-- <		When {max} is negative -{max} lines from the end of the file
-- 		are returned, or as many as there are.
-- 		When {max} is zero the result is an empty list.
-- 		Note that without {max} the whole file is read into memory.
-- 		Also note that there is no recognition of encoding.  Read a
-- 		file into a buffer if you need to.
-- 		When the file can't be opened an error message is given and
-- 		the result is an empty list.
-- 		Also see |writefile()|.
--- @return list
function vim.fn.readfile(fname, binary, max) end

-- Move the Vim server with the name {server} to the foreground.
-- 		This works like: >
-- 			remote_expr({server}, "foreground()")
-- <		Except that on Win32 systems the client does the work, to work
-- 		around the problem that the OS doesn't always allow the server
-- 		to bring itself to the foreground.
-- 		Note: This does not restore the window if it was minimized,
-- 		like foreground() does.
-- 		This function is not available in the |sandbox|.
-- 		{only in the Win32 GUI and the Win32 console version}
--- @return number
function vim.fn.remote_foreground(server) end

-- Return the natural logarithm (base e) of {expr} as a |Float|.
-- 		{expr} must evaluate to a |Float| or a |Number| in the range
-- 		(0, inf].
-- 		Examples: >
-- 			:echo log(10)
-- <			2.302585 >
-- 			:echo log(exp(5))
-- <			5.0
--- @return float
function vim.fn.log(expr) end

-- Returns a positive number if there are available strings
-- 		from {serverid}.  Copies any reply string into the variable
-- 		{retvar} if specified.  {retvar} must be a string with the
-- 		name of a variable.
-- 		Returns zero if none are available.
-- 		Returns -1 if something is wrong.
-- 		See also |clientserver|.
-- 		This function is not available in the |sandbox|.
-- 		Examples: >
-- 			:let repl = ""
-- 			:echo "PEEK: ".remote_peek(id, "repl").": ".repl
--- @return number
function vim.fn.remote_peek(serverid, retvar) end

-- Return the oldest available reply from {serverid} and consume
-- 		it.  Unless a {timeout} in seconds is given, it blocks until a
-- 		reply is available.
-- 		See also |clientserver|.
-- 		This function is not available in the |sandbox|.
-- 		Example: >
-- 			:echo remote_read(id)
-- <
--- @return string
function vim.fn.remote_read(serverid, timeout) end

-- Get the ANSI color palette in use by terminal {buf}.
-- 		Returns a List of length 16 where each element is a String
-- 		representing a color in hexadecimal "#rrggbb" format.
-- 		Also see |term_setansicolors()| and |g:terminal_ansi_colors|.
-- 		If neither was used returns the default colors.
--
-- 		{buf} is used as with |term_getsize()|.  If the buffer does not
-- 		exist or is not a terminal window, an empty list is returned.
--
-- 		Can also be used as a |method|: >
-- 			GetBufnr()->term_getansicolors()
--
-- <		{only available when compiled with GUI enabled and/or the
-- 		|+termguicolors| feature}
--- @return list
function vim.fn.term_getansicolors(buf) end

-- Send the {string} to {server}.  The string is sent as input
-- 		keys and the function returns immediately.  At the Vim server
-- 		the keys are not mapped |:map|.
-- 		If {idvar} is present, it is taken as the name of a variable
-- 		and a {serverid} for later use with remote_read() is stored
-- 		there.
-- 		See also |clientserver| |RemoteReply|.
-- 		This function is not available in the |sandbox|.
--
-- 		Note: Any errors will be reported in the server and may mess
-- 		up the display.
-- 		Examples: >
-- 		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
-- 		 \ remote_read(serverid)
--
-- 		:autocmd NONE RemoteReply *
-- 		 \ echo remote_read(expand("<amatch>"))
-- 		:echo remote_send("gvim", ":sleep 10 | echo ".
-- 		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
-- <
--- @return string
function vim.fn.remote_send(server, string, idvar) end

-- Become the server {name}.  This fails if already running as a
-- 		server, when |v:servername| is not empty.
--- @return none
function vim.fn.remote_startserver(name) end

-- Returns a |List| with Numbers:
-- 		- If only {expr} is specified: [0, 1, ..., {expr} - 1]
-- 		- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]
-- 		- If {stride} is specified: [{expr}, {expr} + {stride}, ...,
-- 		  {max}] (increasing {expr} with {stride} each time, not
-- 		  producing a value past {max}).
-- 		When the maximum is one before the start the result is an
-- 		empty list.  When the maximum is more than one before the
-- 		start this is an error.
-- 		Examples: >
-- 			range(4)		" [0, 1, 2, 3]
-- 			range(2, 4)		" [2, 3, 4]
-- 			range(2, 9, 3)		" [2, 5, 8]
-- 			range(2, -2, -1)	" [2, 1, 0, -1, -2]
-- 			range(0)		" []
-- 			range(2, 0)		" error!
-- <
--- @return list
function vim.fn.range(expr, max, stride) end

-- Return {text} as a String where any character in {mask} is
-- 		removed from the beginning and  end of {text}.
-- 		If {mask} is not given, {mask} is all characters up to 0x20,
-- 		which includes Tab, space, NL and CR, plus the non-breaking
-- 		space character 0xa0.
-- 		This code deals with multibyte characters properly.
--
-- 		Examples: >
-- 			echo trim("   some text ")
-- <		returns "some text" >
-- 			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") . "_TAIL"
-- <		returns "RESERVE_TAIL" >
-- 			echo trim("rm<Xrm<>X>rrm", "rm<>")
-- <		returns "Xrm<>X" (characters in the middle are not removed)
--- @return string
function vim.fn.trim(text, mask) end

-- Return the largest integral value less than or equal to
-- 		{expr} as a |Float| (round down).
-- 		{expr} must evaluate to a |Float| or a |Number|.
-- 		Examples: >
-- 			echo floor(1.856)
-- <			1.0  >
-- 			echo floor(-5.456)
-- <			-6.0  >
-- 			echo floor(4.0)
-- <			4.0
--- @return float
function vim.fn.floor(expr) end

-- Get the |window-ID| for the specified window.
-- 		When {win} is missing use the current window.
-- 		With {win} this is the window number.  The top window has
-- 		number 1.
-- 		Without {tab} use the current tab, otherwise the tab with
-- 		number {tab}.  The first tab has number one.
-- 		Return zero if the window cannot be found.
--- @return number
function vim.fn.win_getid(win, tab) end

-- Return the byte count from the start of the buffer for line
-- 		{lnum}.  This includes the end-of-line character, depending on
-- 		the 'fileformat' option for the current buffer.  The first
-- 		line returns 1. UTF-8 encoding is used, 'fileencoding' is
-- 		ignored.  This can also be used to get the byte count for the
-- 		line just below the last line: >
-- 			line2byte(line("$") + 1)
-- <		This is the buffer size plus one.  If 'fileencoding' is empty
-- 		it is the file size plus one.
-- 		When {lnum} is invalid -1 is returned.
-- 		Also see |byte2line()|, |go| and |:goto|.
--- @return number
function vim.fn.line2byte(lnum) end

-- On MS-Windows, when {filename} is a shortcut (a .lnk file),
-- 		returns the path the shortcut points to in a simplified form.
-- 		On Unix, repeat resolving symbolic links in all path
-- 		components of {filename} and return the simplified result.
-- 		To cope with link cycles, resolving of symbolic links is
-- 		stopped after 100 iterations.
-- 		On other systems, return the simplified {filename}.
-- 		The simplification step is done as by |simplify()|.
-- 		resolve() keeps a leading path component specifying the
-- 		current directory (provided the result is still a relative
-- 		path name) and also keeps a trailing path separator.
--- @return string
function vim.fn.resolve(filename) end

-- The result is a String, which is the text {expr} converted
-- 		from encoding {from} to encoding {to}.
-- 		When the conversion completely fails an empty string is
-- 		returned.  When some characters could not be converted they
-- 		are replaced with "?".
-- 		The encoding names are whatever the iconv() library function
-- 		can accept, see ":!man 3 iconv".
-- 		Most conversions require Vim to be compiled with the |+iconv|
-- 		feature.  Otherwise only UTF-8 to latin1 conversion and back
-- 		can be done.
-- 		Note that Vim uses UTF-8 for all Unicode encodings, conversion
-- 		from/to UCS-2 is automatically changed to use UTF-8.  You
-- 		cannot use UCS-2 in a string anyway, because of the NUL bytes.
--- @return string
function vim.fn.iconv(expr, from, to) end

-- Round off {expr} to the nearest integral value and return it
-- 		as a |Float|.  If {expr} lies halfway between two integral
-- 		values, then use the larger one (away from zero).
-- 		{expr} must evaluate to a |Float| or a |Number|.
-- 		Examples: >
-- 			echo round(0.456)
-- <			0.0  >
-- 			echo round(4.5)
-- <			5.0 >
-- 			echo round(-4.5)
-- <			-5.0
--- @return float
function vim.fn.round(expr) end

-- The result is the swap file path of the buffer {expr}.
-- 		For the use of {expr}, see |bufname()| above.
-- 		If buffer {expr} is the current buffer, the result is equal to
-- 		|:swapname| (unless no swap file).
-- 		If buffer {expr} has no swap file, returns an empty string.
--- @return string
function vim.fn.swapname(expr) end

-- The result is a String, which is a copy of {expr}, in which
-- 		the first match of {pat} is replaced with {sub}.
-- 		When {flags} is "g", all matches of {pat} in {expr} are
-- 		replaced.  Otherwise {flags} should be "".
--
-- 		This works like the ":substitute" command (without any flags).
-- 		But the matching with {pat} is always done like the 'magic'
-- 		option is set and 'cpoptions' is empty (to make scripts
-- 		portable).  'ignorecase' is still relevant, use |/\c| or |/\C|
-- 		if you want to ignore or match case and ignore 'ignorecase'.
-- 		'smartcase' is not used.  See |string-match| for how {pat} is
-- 		used.
--
-- 		A "~" in {sub} is not replaced with the previous {sub}.
-- 		Note that some codes in {sub} have a special meaning
-- 		|sub-replace-special|.  For example, to replace something with
-- 		"\n" (two characters), use "\\\\n" or '\\n'.
--
-- 		When {pat} does not match in {expr}, {expr} is returned
-- 		unmodified.
--
-- 		Example: >
-- 			:let &path = substitute(&path, ",\\=[^,]*$", "", "")
-- <		This removes the last component of the 'path' option. >
-- 			:echo substitute("testing", ".*", "\\U\\0", "")
-- <		results in "TESTING".
--
-- 		When {sub} starts with "\=", the remainder is interpreted as
-- 		an expression. See |sub-replace-expression|.  Example: >
-- 			:echo substitute(s, '%\(\x\x\)',
-- 			   \ '\=nr2char("0x" . submatch(1))', 'g')
--
-- <		When {sub} is a Funcref that function is called, with one
-- 		optional argument.  Example: >
-- 		   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')
-- <		The optional argument is a list which contains the whole
-- 		matched string and up to nine submatches, like what
-- 		|submatch()| returns.  Example: >
-- 		   :echo substitute(s, '%\(\x\x\)', {m -> '0x' . m[1]}, 'g')
--- @return string
function vim.fn.substitute(expr, pat, sub, flags) end

-- Set the ANSI color palette used by terminal {buf}.
-- 		{colors} must be a List of 16 valid color names or hexadecimal
-- 		color codes, like those accepted by |highlight-guifg|.
-- 		Also see |term_getansicolors()| and |g:terminal_ansi_colors|.
--
-- 		The colors normally are:
-- 			0    black
-- 			1    dark red
-- 			2    dark green
-- 			3    brown
-- 			4    dark blue
-- 			5    dark magenta
-- 			6    dark cyan
-- 			7    light grey
-- 			8    dark grey
-- 			9    red
-- 			10   green
-- 			11   yellow
-- 			12   blue
-- 			13   magenta
-- 			14   cyan
-- 			15   white
--
-- 		These colors are used in the GUI and in the terminal when
-- 		'termguicolors' is set.  When not using GUI colors (GUI mode
-- 		or 'termguicolors'), the terminal window always uses the 16
-- 		ANSI colors of the underlying terminal.
--
-- 		Can also be used as a |method|: >
-- 			GetBufnr()->term_setansicolors(colors)
--
-- <		{only available with GUI enabled and/or the |+termguicolors|
-- 		feature}
--- @return none
function vim.fn.term_setansicolors(buf, colors) end

-- Like |screenchar()|, but return the attribute.  This is a rather
-- 		arbitrary number that can only be used to compare to the
-- 		attribute at other positions.
--- @return number
function vim.fn.screenattr(row, col) end

-- The result is a Number, which is the character at position
-- 		[row, col] on the screen.  This works for every possible
-- 		screen position, also status lines, window separators and the
-- 		command line.  The top left position is row one, column one
-- 		The character excludes composing characters.  For double-byte
-- 		encodings it may only be the first byte.
-- 		This is mainly to be used for testing.
-- 		Returns -1 when row or col is out of range.
--- @return number
function vim.fn.screenchar(row, col) end

-- Set the current character search information to {dict},
-- 		which contains one or more of the following entries:
--
-- 		    char	character which will be used for a subsequent
-- 				|,| or |;| command; an empty string clears the
-- 				character search
-- 		    forward	direction of character search; 1 for forward,
-- 				0 for backward
-- 		    until	type of character search; 1 for a |t| or |T|
-- 				character search, 0 for an |f| or |F|
-- 				character search
--
-- 		This can be useful to save/restore a user's character search
-- 		from a script: >
-- 			:let prevsearch = getcharsearch()
-- 			:" Perform a command which clobbers user's search
-- 			:call setcharsearch(prevsearch)
-- <		Also see |getcharsearch()|.
--- @param dict dictionary
--- @return dict
function vim.fn.setcharsearch(dict) end

-- The result is a Number, which is the current screen column of
-- 		the cursor. The leftmost column has number 1.
-- 		This function is mainly used for testing.
--
-- 		Note: Always returns the current screen column, thus if used
-- 		in a command (e.g. ":echo screencol()") it will return the
-- 		column inside the command line, which is 1 when the command is
-- 		executed. To get the cursor position in the file use one of
-- 		the following mappings: >
-- 			nnoremap <expr> GG ":echom ".screencol()."\n"
-- 			nnoremap <silent> GG :echom screencol()<CR>
-- 			noremap GG <Cmd>echom screencol()<Cr>
--- @return number
function vim.fn.screencol() end

-- The result is a Dict with the screen position of the text
-- 		character in window {winid} at buffer line {lnum} and column
-- 		{col}.  {col} is a one-based byte index.
-- 		The Dict has these members:
-- 			row	screen row
-- 			col	first screen column
-- 			endcol	last screen column
-- 			curscol	cursor screen column
-- 		If the specified position is not visible, all values are zero.
-- 		The "endcol" value differs from "col" when the character
-- 		occupies more than one screen cell.  E.g. for a Tab "col" can
-- 		be 1 and "endcol" can be 8.
-- 		The "curscol" value is where the cursor would be placed.  For
-- 		a Tab it would be the same as "endcol", while for a double
-- 		width character it would be the same as "col".
--- @return dict
function vim.fn.screenpos(winid, lnum, col) end

-- Return a |List|, which is the stack of syntax items at the
-- 		position {lnum} and {col} in the current window.  Each item in
-- 		the List is an ID like what |synID()| returns.
-- 		The first item in the List is the outer region, following are
-- 		items contained in that one.  The last one is what |synID()|
-- 		returns, unless not the whole item is highlighted or it is a
-- 		transparent item.
-- 		This function is useful for debugging a syntax file.
-- 		Example that shows the syntax stack under the cursor: >
-- 			for id in synstack(line("."), col("."))
-- 			   echo synIDattr(id, "name")
-- 			endfor
-- <		When the position specified with {lnum} and {col} is invalid
-- 		nothing is returned.  The position just after the last
-- 		character in a line and the first column in an empty line are
-- 		valid positions.
--- @return list
function vim.fn.synstack(lnum, col) end

-- The result is a Number, which is the current screen row of the
-- 		cursor.  The top line has number one.
-- 		This function is mainly used for testing.
-- 		Alternatively you can use |winline()|.
--
-- 		Note: Same restrictions as with |screencol()|.
--- @return number
function vim.fn.screenrow() end

-- Add a text property type {name}.  If a property type with this
-- 		name already exists an error is given.  Nothing is returned.
-- 		{props} is a dictionary with these optional fields:
-- 		   bufnr	define the property only for this buffer; this
-- 				avoids name collisions and automatically
-- 				clears the property types when the buffer is
-- 				deleted.
-- 		   highlight	name of highlight group to use
-- 		   priority	when a character has multiple text
-- 				properties the one with the highest priority
-- 				will be used; negative values can be used, the
-- 				default priority is zero
-- 		   combine	when TRUE combine the highlight with any
-- 				syntax highlight; when omitted or FALSE syntax
-- 				highlight will not be used
-- 		   start_incl	when TRUE inserts at the start position will
-- 				be included in the text property
-- 		   end_incl	when TRUE inserts at the end position will be
-- 				included in the text property
--
-- 		See |text-properties| for information about text properties.
--
-- 		Can also be used as a |method|: >
-- 			GetPropName()->prop_type_add(props)
--- @return none
function vim.fn.prop_type_add(name, props) end

-- Search for regexp pattern {pattern}.  The search starts at the
-- 		cursor position (you can use |cursor()| to set it).
--
-- 		When a match has been found its line number is returned.
-- 		If there is no match a 0 is returned and the cursor doesn't
-- 		move.  No error message is given.
--
-- 		{flags} is a String, which can contain these character flags:
-- 		'b'	search Backward instead of forward
-- 		'c'	accept a match at the Cursor position
-- 		'e'	move to the End of the match
-- 		'n'	do Not move the cursor
-- 		'p'	return number of matching sub-Pattern (see below)
-- 		's'	Set the ' mark at the previous location of the cursor
-- 		'w'	Wrap around the end of the file
-- 		'W'	don't Wrap around the end of the file
-- 		'z'	start searching at the cursor column instead of Zero
-- 		If neither 'w' or 'W' is given, the 'wrapscan' option applies.
--
-- 		If the 's' flag is supplied, the ' mark is set, only if the
-- 		cursor is moved. The 's' flag cannot be combined with the 'n'
-- 		flag.
--
-- 		'ignorecase', 'smartcase' and 'magic' are used.
--
-- 		When the 'z' flag is not given, searching always starts in
-- 		column zero and then matches before the cursor are skipped.
-- 		When the 'c' flag is present in 'cpo' the next search starts
-- 		after the match.  Without the 'c' flag the next search starts
-- 		one column further.
--
-- 		When the {stopline} argument is given then the search stops
-- 		after searching this line.  This is useful to restrict the
-- 		search to a range of lines.  Examples: >
-- 			let match = search('(', 'b', line("w0"))
-- 			let end = search('END', '', line("w$"))
-- <		When {stopline} is used and it is not zero this also implies
-- 		that the search does not wrap around the end of the file.
-- 		A zero value is equal to not giving the argument.
--
-- 		When the {timeout} argument is given the search stops when
-- 		more than this many milliseconds have passed.  Thus when
-- 		{timeout} is 500 the search stops after half a second.
-- 		The value must not be negative.  A zero value is like not
-- 		giving the argument.
--
-- 							*search()-sub-match*
-- 		With the 'p' flag the returned value is one more than the
-- 		first sub-match in \(\).  One if none of them matched but the
-- 		whole pattern did match.
-- 		To get the column number too use |searchpos()|.
--
-- 		The cursor will be positioned at the match, unless the 'n'
-- 		flag is used.
--
-- 		Example (goes over all files in the argument list): >
-- 		    :let n = 1
-- 		    :while n <= argc()	    " loop over all files in arglist
-- 		    :  exe "argument " . n
-- 		    :  " start at the last char in the file and wrap for the
-- 		    :  " first search to find match at start of file
-- 		    :  normal G$
-- 		    :  let flags = "w"
-- 		    :  while search("foo", flags) > 0
-- 		    :	 s/foo/bar/g
-- 		    :	 let flags = "W"
-- 		    :  endwhile
-- 		    :  update		    " write the file if modified
-- 		    :  let n = n + 1
-- 		    :endwhile
-- <
-- 		Example for using some flags: >
-- 		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
-- <		This will search for the keywords "if", "else", and "endif"
-- 		under or after the cursor.  Because of the 'p' flag, it
-- 		returns 1, 2, or 3 depending on which keyword is found, or 0
-- 		if the search fails.  With the cursor on the first word of the
-- 		line:
-- 		    if (foo == 0) | let foo = foo + 1 | endif ~
-- 		the function returns 1.  Without the 'c' flag, the function
-- 		finds the "endif" and returns 3.  The same thing happens
-- 		without the 'e' flag if the cursor is on the "f" of "if".
-- 		The 'n' flag tells the function not to move the cursor.
--- @return number
function vim.fn.search(pattern, flags, stopline, timeout) end

-- Search for the declaration of {name}.
--
-- 		With a non-zero {global} argument it works like |gD|, find
-- 		first match in the file.  Otherwise it works like |gd|, find
-- 		first match in the function.
--
-- 		With a non-zero {thisblock} argument matches in a {} block
-- 		that ends before the cursor position are ignored.  Avoids
-- 		finding variable declarations only valid in another scope.
--
-- 		Moves the cursor to the found match.
-- 		Returns zero for success, non-zero for failure.
-- 		Example: >
-- 			if searchdecl('myvar') == 0
-- 			   echo getline('.')
-- 			endif
-- <
-- 							*searchpair()*
-- searchpair({start}, {middle}, {end} [, {flags} [, {skip}
-- 				[, {stopline} [, {timeout}]]]])
-- 		Search for the match of a nested start-end pair.  This can be
-- 		used to find the "endif" that matches an "if", while other
-- 		if/endif pairs in between are ignored.
-- 		The search starts at the cursor.  The default is to search
-- 		forward, include 'b' in {flags} to search backward.
-- 		If a match is found, the cursor is positioned at it and the
-- 		line number is returned.  If no match is found 0 or -1 is
-- 		returned and the cursor doesn't move.  No error message is
-- 		given.
--
-- 		{start}, {middle} and {end} are patterns, see |pattern|.  They
-- 		must not contain \( \) pairs.  Use of \%( \) is allowed.  When
-- 		{middle} is not empty, it is found when searching from either
-- 		direction, but only when not in a nested start-end pair.  A
-- 		typical use is: >
-- 			searchpair('\<if\>', '\<else\>', '\<endif\>')
-- <		By leaving {middle} empty the "else" is skipped.
--
-- 		{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with
-- 		|search()|.  Additionally:
-- 		'r'	Repeat until no more matches found; will find the
-- 			outer pair.  Implies the 'W' flag.
-- 		'm'	Return number of matches instead of line number with
-- 			the match; will be > 1 when 'r' is used.
-- 		Note: it's nearly always a good idea to use the 'W' flag, to
-- 		avoid wrapping around the end of the file.
--
-- 		When a match for {start}, {middle} or {end} is found, the
-- 		{skip} expression is evaluated with the cursor positioned on
-- 		the start of the match.  It should return non-zero if this
-- 		match is to be skipped.  E.g., because it is inside a comment
-- 		or a string.
-- 		When {skip} is omitted or empty, every match is accepted.
-- 		When evaluating {skip} causes an error the search is aborted
-- 		and -1 returned.
--  		{skip} can be a string, a lambda, a funcref or a partial.
-- 		Anything else makes the function fail.
--
-- 		For {stopline} and {timeout} see |search()|.
--
-- 		The value of 'ignorecase' is used.  'magic' is ignored, the
-- 		patterns are used like it's on.
--
-- 		The search starts exactly at the cursor.  A match with
-- 		{start}, {middle} or {end} at the next character, in the
-- 		direction of searching, is the first one found.  Example: >
-- 			if 1
-- 			  if 2
-- 			  endif 2
-- 			endif 1
-- <		When starting at the "if 2", with the cursor on the "i", and
-- 		searching forwards, the "endif 2" is found.  When starting on
-- 		the character just before the "if 2", the "endif 1" will be
-- 		found.  That's because the "if 2" will be found first, and
-- 		then this is considered to be a nested if/endif from "if 2" to
-- 		"endif 2".
-- 		When searching backwards and {end} is more than one character,
-- 		it may be useful to put "\zs" at the end of the pattern, so
-- 		that when the cursor is inside a match with the end it finds
-- 		the matching start.
--
-- 		Example, to find the "endif" command in a Vim script: >
--
-- 	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
-- 			\ 'getline(".") =~ "^\\s*\""')
--
-- <		The cursor must be at or after the "if" for which a match is
-- 		to be found.  Note that single-quote strings are used to avoid
-- 		having to double the backslashes.  The skip expression only
-- 		catches comments at the start of a line, not after a command.
-- 		Also, a word "en" or "if" halfway through a line is considered
-- 		a match.
-- 		Another example, to search for the matching "{" of a "}": >
--
-- 	:echo searchpair('{', '', '}', 'bW')
--
-- <		This works when the cursor is at or before the "}" for which a
-- 		match is to be found.  To reject matches that syntax
-- 		highlighting recognized as strings: >
--
-- 	:echo searchpair('{', '', '}', 'bW',
-- 	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
-- <
-- 							*searchpairpos()*
-- searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
-- 				[, {stopline} [, {timeout}]]]])
-- 		Same as |searchpair()|, but returns a |List| with the line and
-- 		column position of the match. The first element of the |List|
-- 		is the line number and the second element is the byte index of
-- 		the column position of the match.  If no match is found,
-- 		returns [0, 0]. >
--
-- 			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
-- <
-- 		See |match-parens| for a bigger and more useful example.
--- @return number
function vim.fn.searchdecl(name, global, thisblock) end

-- In a nvim launched with the |--headless| option, this opens
-- 		stdin and stdout as a |channel|. This function can only be
-- 		invoked once per instance. See |channel-stdio| for more
-- 		information and examples. Note that stderr is not handled by
-- 		this function, see |v:stderr|.
--
-- 		Returns a |channel| ID. Close the stdio descriptors with |chanclose()|.
-- 		Use |chansend()| to send data to stdout, and
-- 		|rpcrequest()| and |rpcnotify()| to communicate over RPC.
--
-- 		{opts} is a dictionary with these keys:
-- 		  |on_stdin| : callback invoked when stdin is written to.
-- 		  stdin_buffered : read stdin in |channel-buffered| mode.
-- 		  rpc      : If set, |msgpack-rpc| will be used to communicate
-- 			     over stdio
-- 		Returns:
-- 		  - The channel ID on success (this is always 1)
-- 		  - 0 on invalid arguments
--- @param dict dictionary
--- @return number
function vim.fn.stdioopen(dict) end

--- @return number
function vim.fn.searchpair(start, middle, _end, flags, ...) end

--- @return list
function vim.fn.searchpairpos(start, middle, _end, flags, ...) end

-- for the current buffer.  This is the 'tags' option expanded.
--- @return list
function vim.fn.tagfiles() end

-- Same as |search()|, but returns a |List| with the line and
-- 		column position of the match. The first element of the |List|
-- 		is the line number and the second element is the byte index of
-- 		the column position of the match. If no match is found,
-- 		returns [0, 0].
-- 		Example: >
-- 	:let [lnum, col] = searchpos('mypattern', 'n')
--
-- <		When the 'p' flag is given then there is an extra item with
-- 		the sub-pattern match number |search()-sub-match|.  Example: >
-- 	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
-- <		In this example "submatch" is 2 when a lowercase letter is
-- 		found |/\l|, 3 when an uppercase letter is found |/\u|.
--- @return list
function vim.fn.searchpos(pattern, flags, stopline, timeout) end

-- Send a reply string to {clientid}.  The most recent {clientid}
-- 		that sent a string can be retrieved with expand("<client>").
-- 		Note:
-- 		This id has to be stored before the next command can be
-- 		received.  I.e. before returning from the received command and
-- 		before calling any commands that waits for input.
-- 		See also |clientserver|.
-- 		Example: >
-- 			:echo server2client(expand("<client>"), "HELLO")
--- @return number
function vim.fn.server2client(clientid, string) end

-- Create directory {name}.
-- 		If {path} is "p" then intermediate directories are created as
-- 		necessary.  Otherwise it must be "".
-- 		If {prot} is given it is used to set the protection bits of
-- 		the new directory.  The default is 0755 (rwxr-xr-x: r/w for
-- 		the user readable for others).  Use 0700 to make it unreadable
-- 		for others.
--
-- 		{prot} is applied for all parts of {name}.  Thus if you create
-- 		/tmp/foo/bar then /tmp/foo will be created with 0700. Example: >
-- 			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
-- <		This function is not available in the |sandbox|.
--
-- 		If you try to create an existing directory with {path} set to
-- 		"p" mkdir() will silently exit.
--- @return number
function vim.fn.mkdir(name, path, prot) end

-- Returns a list of server addresses, or empty if all servers
-- 		were stopped. |serverstart()| |serverstop()|
-- 		Example: >
-- 			:echo serverlist()
--- @return string
function vim.fn.serverlist() end

-- Return the power of {x} to the exponent {y} as a |Float|.
-- 		{x} and {y} must evaluate to a |Float| or a |Number|.
-- 		Examples: >
-- 			:echo pow(3, 3)
-- <			27.0 >
-- 			:echo pow(2, 16)
-- <			65536.0 >
-- 			:echo pow(32, 0.20)
-- <			2.0
--- @return float
function vim.fn.pow(x, y) end

-- Set line {lnum} to {text} in buffer {expr}.  To insert
-- 		lines use |append()|.
--
-- 		For the use of {expr}, see |bufname()| above.
--
-- 		{lnum} is used like with |setline()|.
-- 		This works like |setline()| for the specified buffer.
-- 		On success 0 is returned, on failure 1 is returned.
--
-- 		If {expr} is not a valid buffer or {lnum} is not valid, an
-- 		error message is given.
--- @return number
function vim.fn.setbufline(expr, lnum, line) end

-- Tells Nvim the number of elements displaying in the popumenu,
--                 to decide <PageUp> and <PageDown> movement.
--
--                 Parameters: ~
--                     {height}  Popupmenu height, must be greater than zero.
function vim.fn.nvim_ui_pum_set_height(height) end

-- Set option or local variable {varname} in buffer {expr} to
-- 		{val}.
-- 		This also works for a global or local window option, but it
-- 		doesn't work for a global or local window variable.
-- 		For a local window option the global value is unchanged.
-- 		For the use of {expr}, see |bufname()| above.
-- 		Note that the variable name without "b:" must be used.
-- 		Examples: >
-- 			:call setbufvar(1, "&mod", 1)
-- 			:call setbufvar("todo", "myvar", "foobar")
-- <		This function is not available in the |sandbox|.
--- @return set
function vim.fn.setbufvar(expr, varname, val) end

-- Given {attr}, a value returned by term_scrape() in the "attr"
-- 		item, return whether {what} is on.  {what} can be one of:
-- 			bold
-- 			italic
-- 			underline
-- 			strike
-- 			reverse
--
-- 		Can also be used as a |method|: >
-- 			GetAttr()->term_getattr()
--- @return number
function vim.fn.term_getattr(attr, what) end

-- Call function {funcname} in the run-time library {libname}
-- 		with single argument {argument}.
-- 		This is useful to call functions in a library that you
-- 		especially made to be used with Vim.  Since only one argument
-- 		is possible, calling standard library functions is rather
-- 		limited.
-- 		The result is the String returned by the function.  If the
-- 		function returns NULL, this will appear as an empty string ""
-- 		to Vim.
-- 		If the function returns a number, use libcallnr()!
-- 		If {argument} is a number, it is passed to the function as an
-- 		int; if {argument} is a string, it is passed as a
-- 		null-terminated string.
-- 		This function will fail in |restricted-mode|.
--
-- 		libcall() allows you to write your own 'plug-in' extensions to
-- 		Vim without having to recompile the program.  It is NOT a
-- 		means to call system functions!  If you try to do so Vim will
-- 		very probably crash.
--
-- 		For Win32, the functions you write must be placed in a DLL
-- 		and use the normal C calling convention (NOT Pascal which is
-- 		used in Windows System DLLs).  The function must take exactly
-- 		one parameter, either a character pointer or a long integer,
-- 		and must return a character pointer or NULL.  The character
-- 		pointer returned must point to memory that will remain valid
-- 		after the function has returned (e.g. in static data in the
-- 		DLL).  If it points to allocated memory, that memory will
-- 		leak away.  Using a static buffer in the function should work,
-- 		it's then freed when the DLL is unloaded.
--
-- 		WARNING: If the function returns a non-valid pointer, Vim may
-- 		crash!	This also happens if the function returns a number,
-- 		because Vim thinks it's a pointer.
-- 		For Win32 systems, {libname} should be the filename of the DLL
-- 		without the ".DLL" suffix.  A full path is only required if
-- 		the DLL is not in the usual places.
-- 		For Unix: When compiling your own plugins, remember that the
-- 		object code must be compiled as position-independent ('PIC').
-- 		Examples: >
-- 			:echo libcall("libc.so", "getenv", "HOME")
-- <
--- @return string
function vim.fn.libcall(lib, func, arg) end

-- Convert a |readfile()|-style list to a list of VimL objects.
-- 		Example: >
-- 			let fname = expand('~/.config/nvim/shada/main.shada')
-- 			let mpack = readfile(fname, 'b')
-- 			let shada_objects = msgpackparse(mpack)
-- <		This will read ~/.config/nvim/shada/main.shada file to
-- 		`shada_objects` list.
--
-- 		Limitations:
-- 		1. Mapping ordering is not preserved unless messagepack
-- 		   mapping is dumped using generic  mapping
-- 		   (|msgpack-special-map|).
-- 		2. Since the parser aims to preserve all data untouched
-- 		   (except for 1.) some strings are parsed to
-- 		   |msgpack-special-dict| format which is not convenient to
-- 		   use.
-- 							*msgpack-special-dict*
-- 		Some messagepack strings may be parsed to special
-- 		dictionaries. Special dictionaries are dictionaries which
--
-- 		1. Contain exactly two keys: `_TYPE` and `_VAL`.
-- 		2. `_TYPE` key is one of the types found in |v:msgpack_types|
-- 		   variable.
-- 		3. Value for `_VAL` has the following format (Key column
-- 		   contains name of the key from |v:msgpack_types|):
--
-- 		Key	Value ~
-- 		nil	Zero, ignored when dumping.  Not returned by
-- 			|msgpackparse()| since |v:null| was introduced.
-- 		boolean	One or zero.  When dumping it is only checked that
-- 			value is a |Number|.  Not returned by |msgpackparse()|
-- 			since |v:true| and |v:false| were introduced.
-- 		integer	|List| with four numbers: sign (-1 or 1), highest two
-- 			bits, number with bits from 62nd to 31st, lowest 31
-- 			bits. I.e. to get actual number one will need to use
-- 			code like >
-- 				_VAL[0] * ((_VAL[1] << 62)
-- 				           & (_VAL[2] << 31)
-- 				           & _VAL[3])
-- <			Special dictionary with this type will appear in
-- 			|msgpackparse()| output under one of the following
-- 			circumstances:
-- 			1. |Number| is 32-bit and value is either above
-- 			   INT32_MAX or below INT32_MIN.
-- 			2. |Number| is 64-bit and value is above INT64_MAX. It
-- 			   cannot possibly be below INT64_MIN because msgpack
-- 			   C parser does not support such values.
-- 		float	|Float|. This value cannot possibly appear in
-- 			|msgpackparse()| output.
-- 		string	|readfile()|-style list of strings. This value will
-- 			appear in |msgpackparse()| output if string contains
-- 			zero byte or if string is a mapping key and mapping is
-- 			being represented as special dictionary for other
-- 			reasons.
-- 		binary	|readfile()|-style list of strings. This value will
-- 			appear in |msgpackparse()| output if binary string
-- 			contains zero byte.
-- 		array	|List|. This value cannot appear in |msgpackparse()|
-- 			output.
-- 							*msgpack-special-map*
-- 		map	|List| of |List|s with two items (key and value) each.
-- 			This value will appear in |msgpackparse()| output if
-- 			parsed mapping contains one of the following keys:
-- 			1. Any key that is not a string (including keys which
-- 			   are binary strings).
-- 			2. String with NUL byte inside.
-- 			3. Duplicate key.
-- 			4. Empty key.
-- 		ext	|List| with two values: first is a signed integer
-- 			representing extension type. Second is
-- 			|readfile()|-style list of strings.
--- @param list any[]
--- @return list
function vim.fn.msgpackparse(list) end

-- Set the cursor position in the command line to byte position
-- 		{pos}.  The first position is 1.
-- 		Use |getcmdpos()| to obtain the current position.
-- 		Only works while editing the command line, thus you must use
-- 		|c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For
-- 		|c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is
-- 		set after the command line is set to the expression.  For
-- 		|c_CTRL-R_=| it is set after evaluating the expression but
-- 		before inserting the resulting text.
-- 		When the number is too big the cursor is put at the end of the
-- 		line.  A number smaller than one has undefined results.
-- 		Returns 0 when successful, 1 when not editing the command
-- 		line.
--- @return number
function vim.fn.setcmdpos(pos) end

-- Get the amount of indent for line {lnum} according the lisp
-- 		indenting rules, as with 'lisp'.
-- 		The indent is counted in spaces, the value of 'tabstop' is
-- 		relevant.  {lnum} is used just like in |getline()|.
-- 		When {lnum} is invalid or Vim was not compiled the
-- 		|+lispindent| feature, -1 is returned.
--- @return number
function vim.fn.lispindent(lnum) end

-- Return the hyperbolic sine of {expr} as a |Float| in the range
-- 		[-inf, inf].
-- 		{expr} must evaluate to a |Float| or a |Number|.
-- 		Examples: >
-- 			:echo sinh(0.5)
-- <			0.521095 >
-- 			:echo sinh(-0.9)
-- <			-1.026517
--- @return float
function vim.fn.sinh(expr) end

-- Set line {lnum} of the current buffer to {text}.  To insert
-- 		lines use |append()|. To set lines in another buffer use
-- 		|setbufline()|.
--
-- 		{lnum} is used like with |getline()|.
-- 		When {lnum} is just below the last line the {text} will be
-- 		added as a new line.
--
-- 		If this succeeds, 0 is returned.  If this fails (most likely
-- 		because {lnum} is invalid) 1 is returned.
--
-- 		Example: >
-- 			:call setline(5, strftime("%c"))
--
-- <		When {text} is a |List| then line {lnum} and following lines
-- 		will be set to the items in the list.  Example: >
-- 			:call setline(5, ['aaa', 'bbb', 'ccc'])
-- <		This is equivalent to: >
-- 			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
-- 			:  call setline(n, l)
-- 			:endfor
--
-- <		Note: The '[ and '] marks are not set.
--- @return number
function vim.fn.setline(lnum, line) end

-- The result is the {nr}th file in the argument list.  See
-- 		|arglist|.  "argv(0)" is the first one.  Example: >
-- 	:let i = 0
-- 	:while i < argc()
-- 	:  let f = escape(fnameescape(argv(i)), '.')
-- 	:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
-- 	:  let i = i + 1
-- 	:endwhile
-- <		Without the {nr} argument, or when {nr} is -1, a |List| with
-- 		the whole |arglist| is returned.
--
-- 		The {winid} argument specifies the window ID, see |argc()|.
--- @return list
function vim.fn.argv(_1, winid) end

-- Create or replace or add to the location list for window {nr}.
-- 		{nr} can be the window number or the |window-ID|.
-- 		When {nr} is zero the current window is used.
--
-- 		For a location list window, the displayed location list is
-- 		modified.  For an invalid window number {nr}, -1 is returned.
-- 		Otherwise, same as |setqflist()|.
-- 		Also see |location-list|.
--
-- 		If the optional {what} dictionary argument is supplied, then
-- 		only the items listed in {what} are set. Refer to |setqflist()|
-- 		for the list of supported keys in {what}.
--- @param list any[]
--- @return number
function vim.fn.setloclist(nr, list, action, what) end

-- Restores a list of matches saved by |getmatches() for the
-- 		current window|.  Returns 0 if successful, otherwise -1.  All
-- 		current matches are cleared before the list is restored.  See
-- 		example for |getmatches()|.
--- @param list any[]
--- @return number
function vim.fn.setmatches(list) end

-- Modify file name {fname} according to {mods}.  {mods} is a
-- 		string of characters like it is used for file names on the
-- 		command line.  See |filename-modifiers|.
-- 		Example: >
-- 			:echo fnamemodify("main.c", ":p:h")
-- <		results in: >
-- 			/home/mool/vim/vim/src
-- <		Note: Environment variables don't work in {fname}, use
-- 		|expand()| first then.
--- @return string
function vim.fn.fnamemodify(fname, mods) end

-- Set the register {regname} to {value}.
-- 		{value} may be any value returned by |getreg()|, including
-- 		a |List|.
-- 		If {options} contains "a" or {regname} is upper case,
-- 		then the value is appended.
-- 		{options} can also contain a register type specification:
-- 		    "c" or "v"	      |charwise| mode
-- 		    "l" or "V"	      |linewise| mode
-- 		    "b" or "<CTRL-V>" |blockwise-visual| mode
-- 		If a number immediately follows "b" or "<CTRL-V>" then this is
-- 		used as the width of the selection - if it is not specified
-- 		then the width of the block is set to the number of characters
-- 		in the longest line (counting a <Tab> as 1 character).
-- 		If {options} contains "u" or '"', then the unnamed register is
-- 		set to point to register {regname}.
--
-- 		If {options} contains no register settings, then the default
-- 		is to use character mode unless {value} ends in a <NL> for
-- 		string {value} and linewise mode for list {value}. Blockwise
-- 		mode is never selected automatically.
-- 		Returns zero for success, non-zero for failure.
--
-- 							*E883*
-- 		Note: you may not use |List| containing more than one item to
-- 		      set search and expression registers. Lists containing no
-- 		      items act like empty strings.
--
-- 		Examples: >
-- 			:call setreg(v:register, @*)
-- 			:call setreg('*', @%, 'ac')
-- 			:call setreg('a', "1\n2\n3", 'b5')
--
-- <		This example shows using the functions to save and restore a
-- 		register: >
-- 			:let var_a = getreg('a', 1, 1)
-- 			:let var_amode = getregtype('a')
-- 			    ....
-- 			:call setreg('a', var_a, var_amode)
-- <		Note: you may not reliably restore register value
-- 		without using the third argument to |getreg()| as without it
-- 		newlines are represented as newlines AND Nul bytes are
-- 		represented as newlines as well, see |NL-used-for-Nul|.
--
-- 		You can also change the type of a register by appending
-- 		nothing: >
-- 			:call setreg('a', '', 'al')
--- @return number
function vim.fn.setreg(n, v, opt) end

-- Set tab-local variable {varname} to {val} in tab page {tabnr}.
-- 		|t:var|
-- 		Note that the variable name without "t:" must be used.
-- 		Tabs are numbered starting with one.
-- 		This function is not available in the |sandbox|.
--- @return set
function vim.fn.settabvar(nr, varname, val) end

-- Sort the items in {list} in-place.  Returns {list}.
--
-- 		If you want a list to remain unmodified make a copy first: >
-- 			:let sortedlist = sort(copy(mylist))
--
-- <		When {func} is omitted, is empty or zero, then sort() uses the
-- 		string representation of each item to sort on.  Numbers sort
-- 		after Strings, |Lists| after Numbers.  For sorting text in the
-- 		current buffer use |:sort|.
--
-- 		When {func} is given and it is '1' or 'i' then case is
-- 		ignored.
--
-- 		When {func} is given and it is 'n' then all items will be
-- 		sorted numerical (Implementation detail: This uses the
-- 		strtod() function to parse numbers, Strings, Lists, Dicts and
-- 		Funcrefs will be considered as being 0).
--
-- 		When {func} is given and it is 'N' then all items will be
-- 		sorted numerical. This is like 'n' but a string containing
-- 		digits will be used as the number they represent.
--
-- 		When {func} is given and it is 'f' then all items will be
-- 		sorted numerical. All values must be a Number or a Float.
--
-- 		When {func} is a |Funcref| or a function name, this function
-- 		is called to compare items.  The function is invoked with two
-- 		items as argument and must return zero if they are equal, 1 or
-- 		bigger if the first one sorts after the second one, -1 or
-- 		smaller if the first one sorts before the second one.
--
-- 		{dict} is for functions with the "dict" attribute.  It will be
-- 		used to set the local variable "self". |Dictionary-function|
--
-- 		The sort is stable, items which compare equal (as number or as
-- 		string) will keep their relative position. E.g., when sorting
-- 		on numbers, text strings will sort next to each other, in the
-- 		same order as they were originally.
--
-- 		Also see |uniq()|.
--
-- 		Example: >
-- 			func MyCompare(i1, i2)
-- 			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
-- 			endfunc
-- 			let sortedlist = sort(mylist, "MyCompare")
-- <		A shorter compare version for this specific simple case, which
-- 		ignores overflow: >
-- 			func MyCompare(i1, i2)
-- 			   return a:i1 - a:i2
-- 			endfunc
-- <
--- @param list any[]
--- @param dict dictionary
--- @return list
function vim.fn.sort(list, func, dict) end

-- Set option or local variable {varname} in window {winnr} to
-- 		{val}.
-- 		Tabs are numbered starting with one.  For the current tabpage
-- 		use |setwinvar()|.
-- 		{winnr} can be the window number or the |window-ID|.
-- 		When {winnr} is zero the current window is used.
-- 		This also works for a global or local buffer option, but it
-- 		doesn't work for a global or local buffer variable.
-- 		For a local buffer option the global value is unchanged.
-- 		Note that the variable name without "w:" must be used.
-- 		Examples: >
-- 			:call settabwinvar(1, 1, "&list", 0)
-- 			:call settabwinvar(3, 2, "myvar", "foobar")
-- <		This function is not available in the |sandbox|.
--- @return set
function vim.fn.settabwinvar(tabnr, winnr, varname, val) end

-- When exiting Vim or trying to close the terminal window in
-- 		another way, {how} defines whether the job in the terminal can
-- 		be stopped.
-- 		When {how} is empty (the default), the job will not be
-- 		stopped, trying to exit will result in |E947|.
-- 		Otherwise, {how} specifies what signal to send to the job.
-- 		See |job_stop()| for the values.
--
-- 		After sending the signal Vim will wait for up to a second to
-- 		check that the job actually stopped.
--
-- 		Can also be used as a |method|: >
-- 			GetBufnr()->term_setkill(how)
--- @return none
function vim.fn.term_setkill(buf, how) end

-- Modify the tag stack of the window {nr} using {dict}.
-- 		{nr} can be the window number or the |window-ID|.
--
-- 		For a list of supported items in {dict}, refer to
-- 		|gettagstack()|. "curidx" takes effect before changing the tag
-- 		stack.
-- 							*E962*
-- 		How the tag stack is modified depends on the {action}
-- 		argument:
-- 		- If {action} is not present or is set to 'r', then the tag
-- 		  stack is replaced.
-- 		- If {action} is set to 'a', then new entries from {dict} are
-- 		  pushed (added) onto the tag stack.
-- 		- If {action} is set to 't', then all the entries from the
-- 		  current entry in the tag stack or "curidx" in {dict} are
-- 		  removed and then new entries are pushed to the stack.
--
-- 		The current index is set to one after the length of the tag
-- 		stack after the modification.
--
-- 		Returns zero for success, -1 for failure.
--
-- 		Examples:
-- 		    Set current index of the tag stack to 4: >
-- 			call settagstack(1005, {'curidx' : 4})
--
-- <		    Empty the tag stack of window 3: >
-- 			call settagstack(3, {'items' : []})
--
-- <		    Push a new item onto the tag stack: >
-- 			let pos = [bufnr('myfile.txt'), 10, 1, 0]
-- 			let newtag = [{'tagname' : 'mytag', 'from' : pos}]
-- 			call settagstack(2, {'items' : newtag}, 'a')
--
-- <		    Save and restore the tag stack: >
-- 			let stack = gettagstack(1003)
-- 			" do something else
-- 			call settagstack(1003, stack)
-- 			unlet stack
-- <
--- @param dict dictionary
--- @return number
function vim.fn.settagstack(nr, dict, action) end

-- Expand wildcards and the following special keywords in {expr}.
-- 		'wildignorecase' applies.
--
-- 		If {list} is given and it is |TRUE|, a List will be returned.
-- 		Otherwise the result is a String and when there are several
-- 		matches, they are separated by <NL> characters.
--
-- 		If the expansion fails, the result is an empty string.  A name
-- 		for a non-existing file is not included, unless {expr} does
-- 		not start with '%', '#' or '<', see below.
--
-- 		When {expr} starts with '%', '#' or '<', the expansion is done
-- 		like for the |cmdline-special| variables with their associated
-- 		modifiers.  Here is a short overview:
--
-- 			%		current file name
-- 			#		alternate file name
-- 			#n		alternate file name n
-- 			<cfile>		file name under the cursor
-- 			<afile>		autocmd file name
-- 			<abuf>		autocmd buffer number (as a String!)
-- 			<amatch>	autocmd matched name
-- 			<sfile>		sourced script file or function name
-- 			<slnum>		sourced script line number or function
-- 					line number
-- 			<sflnum>	script file line number, also when in
-- 					a function
-- 			<cword>		word under the cursor
-- 			<cWORD>		WORD under the cursor
-- 			<client>	the {clientid} of the last received
-- 					message |server2client()|
-- 		Modifiers:
-- 			:p		expand to full path
-- 			:h		head (last path component removed)
-- 			:t		tail (last path component only)
-- 			:r		root (one extension removed)
-- 			:e		extension only
--
-- 		Example: >
-- 			:let &tags = expand("%:p:h") . "/tags"
-- <		Note that when expanding a string that starts with '%', '#' or
-- 		'<', any following text is ignored.  This does NOT work: >
-- 			:let doesntwork = expand("%:h.bak")
-- <		Use this: >
-- 			:let doeswork = expand("%:h") . ".bak"
-- <		Also note that expanding "<cfile>" and others only returns the
-- 		referenced file name without further expansion.  If "<cfile>"
-- 		is "~/.cshrc", you need to do another expand() to have the
-- 		"~/" expanded into the path of the home directory: >
-- 			:echo expand(expand("<cfile>"))
-- <
-- 		There cannot be white space between the variables and the
-- 		following modifier.  The |fnamemodify()| function can be used
-- 		to modify normal file names.
--
-- 		When using '%' or '#', and the current or alternate file name
-- 		is not defined, an empty string is used.  Using "%:p" in a
-- 		buffer with no name, results in the current directory, with a
-- 		'/' added.
--
-- 		When {expr} does not start with '%', '#' or '<', it is
-- 		expanded like a file name is expanded on the command line.
-- 		'suffixes' and 'wildignore' are used, unless the optional
-- 		{nosuf} argument is given and it is |TRUE|.
-- 		Names for non-existing files are included.  The "**" item can
-- 		be used to search in a directory tree.  For example, to find
-- 		all "README" files in the current directory and below: >
-- 			:echo expand("**/README")
-- <
-- 		expand() can also be used to expand variables and environment
-- 		variables that are only known in a shell.  But this can be
-- 		slow, because a shell may be used to do the expansion.  See
-- 		|expr-env-expand|.
-- 		The expanded variable is still handled like a list of file
-- 		names.  When an environment variable cannot be expanded, it is
-- 		left unchanged.  Thus ":echo expand('$FOOBAR')" results in
-- 		"$FOOBAR".
--
-- 		See |glob()| for finding existing files.  See |system()| for
-- 		getting the raw output of an external command.
--- @param list any[]
function vim.fn.expand(expr, nosuf, list) end

